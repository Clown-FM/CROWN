#!/bin/bash

##############################################################################
# This script generates new_coverage which contains rich coverage information
# from coverage generated by crown-fp.
# The script uses all .cil.c files in the current directory and generates 
# new_coverage which shows coverage information for all corresponding .c files.
# 
# input: coverage 
# required programs: parsing_cil                                              
# output: new_coverage file                                                  
##############################################################################

rm -rf new_coverage bid-lnum-exp functions_in_file

#Finding all .cil.c files in current directory.
cilfiles=`ls | grep [.]cil[.]c`

# To extract line/branch information from parse .cil.c files using parsing_cil
# input: namse of .cil.c files
# output:
#   1. functions_in_file (pairs of a file name and a function name in the file)
#   2. bid-lnum-exp (tuples of bid (i.e. branch id), line of the branch w/ bid,
#      expression for the branch w/ bid)
for x in $cilfiles
do
    parsing_cil $x
    printf "\n" >> functions_in_file
done

# Declarations of bidlineMap and bidexprMap
# bidlineMap ( key: bid, value: line of the branch w/ bid)
# bidexprMap ( key: bid, value: expression for the branch w/ bid)
#bash 4.0 or later supports an associated array with -A option
declare -A bidlineMap
declare -A bidexprMap

# Read tuples of bid, line of the branch w/ bid, expression for
# the branch from raw_coverage.
# Then, save the pair of bid and line in bidlineMap,
# pair of bid, expresssion in bidexprMap.
while read branch_line && read expr_line
do
    branch_info=($branch_line)
    #branch_info[0]:bid, branch_info[1]:line of the branch w/ bid
    bidlineMap[${branch_info[0]}]=${branch_info[1]}
    bidexprMap[${branch_info[0]}]=$expr_line
done < bid-lnum-exp

rm -rf bid-lnum-exp

# Decalation of coveredbidMap 
# key: bid
# value: 1 if bid is covered, not defined otherwise 
declare -A coveredbidMap

touch coverage

# Read covered bids from coverage file.
# Then, set the value of coveredbidMap as 1 for covered bid.
while read covered_bid
do
    coveredbidMap[$covered_bid]=1
done < coverage

# file_funcsMap (key: filename, value:funtion names in the file)
declare -A file_funcsMap

# filefunc_covbidsMap
# (key: function name and file name, value: covered bids in the function)
# filefunc_uncovbidsMap
# (key: function name and file name, value: uncovered bids in the function)
declare -A filefunc_covbidsMap
declare -A filefunc_uncovbidsMap

# Read a pair of file name and function name, and bids in the function
while read filefunc && read bids
do
    sep_file_func=($filefunc)
    
    # update file_funcsMap
    file_funcsMap[${sep_file_func[0]}]="${file_funcsMap[${sep_file_func[0]}]} \
        ${sep_file_func[1]}"

    for b in $bids
    do
        if [ "${coveredbidMap[$b]}" = "1" ]
        then # update filefunc_covbidsMap
            filefunc_covbidsMap[$filefunc]="\
                ${filefunc_covbidsMap[$filefunc]} $b"
        else # update filefunc_uncovbidsMap
            filefunc_uncovbidsMap[$filefunc]="\
                ${filefunc_uncovbidsMap[$filefunc]} $b"
        fi
    done
done < functions_in_file

rm -rf functions_in_file

# Coverage information will be stored in new_coverage file
output_file=new_coverage

for file in ${!file_funcsMap[@]}
do
# remove "cil.c" and append "c" to file name
# ex) transform file1.cil.c into file1.c
# then, print file name.
    echo "Source file: ${file::-5}c" >> $output_file

    # iteration for all functions in the file
    for f in ${file_funcsMap[$file]}
    do
        filefunc="$file $f"
        # print function name
        printf "\tFunction: $f\n" >> $output_file

        # A function $f has no branch
        if [ "${filefunc_covbidsMap[$filefunc]}" = "" ] \
                    && [ "${filefunc_uncovbidsMap[$filefunc]}" = "" ]
        then
            printf "\tNo branch exists\n" >> $output_file
    	else
            # $f has no coverd branch
            if [ "${filefunc_covbidsMap[$filefunc]}" = "" ]
            then
                printf "\tNo covered branch\n" >> $output_file
            else
                printf "\tCovered Branches\n" >> $output_file
                printf "\t| Branch ID | Line No. | %-45s |\n" \
                            "Condition to cover the BR" >> $output_file
		           
                # sorting bids in ${func_covbidsMap[$f] by line number.
                # $tmp has 2 columens sorted by 1st column.
                # 1st column is line number and 2nd column is bid
                tmp=`for b in ${filefunc_covbidsMap[$filefunc]}
                do
                    echo ${bidlineMap[$b]} $b
                done | sort -n -k 1`

                # sortedb has 2nd column of $tmp, which is bid sorted by line
                sortedb=`echo "$tmp" | awk '{print $2 }'`

                for b in $sortedb
                do 
                    printf "\t| %9d | %8d | %-45s |\n" \
                "$b" "${bidlineMap[$b]}" "${bidexprMap[$b]}" >> $output_file
                done
            fi

            # $f has no uncovered branch
            if [ "${filefunc_uncovbidsMap[$filefunc]}" = "" ]
            then
                printf "\tNo uncovered Branch\n" >> $output_file
            else
                printf "\tUncovered Branches\n" >> $output_file
                printf "\t| Branch ID | Line No. | %-45s |\n" \
                                "Condition to cover the BR" >> $output_file
                  
                # sorting bids in ${func_uncovbidsMap[$f] by line number.
                # $tmp has 2 columens sorted by 1st column.
                # 1st column is line number and 2nd column is bid
                tmp=`for b in ${filefunc_uncovbidsMap[$filefunc]}
                do
                    echo ${bidlineMap[$b]} $b
                done | sort -n -k 1`

                # sortedb has 2nd column of $tmp, which is bid sorted by line
                sortedb=`echo "$tmp" | awk '{print $2 }'`

                for b in $sortedb
                do 
                    printf "\t| %9d | %8d | %-45s |\n" \
                "$b" "${bidlineMap[$b]}" "${bidexprMap[$b]}" >> $output_file
                done
            fi
        fi
        printf "\n" >> $output_file
    done
done

# Coverage summary per file
printf "\nSummary\n" >> $output_file

tot_cov=0
tot_uncov=0

# iteration for all file names in file_funcsMap
for file in ${!file_funcsMap[@]}
do
    echo "Source file: ${file::-5}c" >> $output_file
    printf "| %-27s | cov BR# | uncov BR# | total BR# | cov rate(%%) \
|\n" "Function name" >> $output_file

    # iteration for all functions in the file_funcsMap
    for f in ${file_funcsMap[$file]}
    do
        filefunc="$file $f"
        cov=`wc -w <<< ${filefunc_covbidsMap[$filefunc]}`
        tot_cov=$(($tot_cov + $cov))
        
        uncov=`wc -w <<< ${filefunc_uncovbidsMap[$filefunc]}`
        tot_uncov=$(($tot_uncov + $uncov))

        sum=$(($cov + $uncov))
        
	if [ $sum -eq 0 ]
        then
            printf "| %-27s | %45s |\n" "$f" "No branch" >> $output_file
        else
            rate=`echo "scale=1;$cov*100/$sum" | bc`
            printf "| %-27s | %7d | %9d | %9d | %11s |\n" \
                        "$f" "$cov" "$uncov" "$sum" "$rate" >> $output_file
        fi
    done  
done

# Total coverage summary
tot_branch=$(($tot_cov + $tot_uncov))

printf "\nTotal Coverage\n" >> $output_file
printf "| cov BR# | uncov BR# | total BR# | cov rate(%%) \
|\n" >> $output_file

# calculate coverage ratio and print it.
if [ $tot_branch -eq 0 ]
then
    rate="NA"
else
    rate=$(echo "scale=1;$tot_cov*100/$tot_branch" | bc)
fi

# print the number of total covered branches, total uncovered branches,
# total branches and covered branch ratio
printf "| %7d | %9d | %9d | %11s |\n" \
                "$tot_cov" "$tot_uncov" "$tot_branch" "$rate" >> $output_file
